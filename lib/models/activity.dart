import 'sync_model.dart';

/// Source of the activity log
enum ActivitySource {
  manual('Manual'),
  auto('Auto'),
  guided('Guided'),
  idleReflection('Idle Reflection');

  final String displayName;
  const ActivitySource(this.displayName);

  static ActivitySource fromString(String value) {
    return ActivitySource.values.firstWhere(
      (e) => e.name == value,
      orElse: () => ActivitySource.manual,
    );
  }
}

/// Represents an activity entry in the focus logger
/// USER-SCOPED: Owned by user_id, device_id is audit only
class Activity implements SyncableModel {
  @override
  final String id;
  @override
  final DateTime createdAt;
  @override
  final DateTime updatedAt;
  @override
  final String? deviceId;
  @override
  final SyncStatus syncStatus;
  
  /// USER-SCOPED: The user who owns this activity
  final String? userId;

  final String name;
  final String category;
  final DateTime startTime;
  final DateTime? endTime;
  final bool isAutoGenerated;
  final bool isRunning;
  final bool isPaused;
  final int pausedDurationSeconds; // Total paused time in seconds
  final DateTime? pausedAt; // When the current pause started
  final ActivitySource source; // manual, auto, or guided
  final String? guidedFlowId; // Reference to guided flow if source is guided
  final String? chainContext; // Previous step ID if part of a flow chain

  Activity({
    String? id,
    DateTime? createdAt,
    DateTime? updatedAt,
    this.deviceId,
    this.userId,
    this.syncStatus = SyncStatus.pending,
    required this.name,
    this.category = 'Uncategorized',
    required this.startTime,
    this.endTime,
    this.isAutoGenerated = false,
    this.isRunning = false,
    this.isPaused = false,
    this.pausedDurationSeconds = 0,
    this.pausedAt,
    this.source = ActivitySource.manual,
    this.guidedFlowId,
    this.chainContext,
  }) : 
    id = id ?? UuidHelper.generate(),
    createdAt = createdAt ?? DateTime.now().toUtc(),
    updatedAt = updatedAt ?? DateTime.now().toUtc();

  /// Duration of the activity (excluding paused time)
  /// Protected: always returns >= 0 duration, never throws
  Duration get duration {
    try {
      final end = endTime ?? DateTime.now();
      final totalDuration = end.difference(startTime);
      
      // Protect against negative total (shouldn't happen, but safety first)
      if (totalDuration.isNegative) {
        return Duration.zero;
      }
      
      // Subtract paused duration
      int activeDurationSeconds = totalDuration.inSeconds - pausedDurationSeconds;
      
      // If currently paused, also subtract time since pause started
      if (isPaused && pausedAt != null) {
        final currentPauseDuration = DateTime.now().difference(pausedAt!).inSeconds;
        activeDurationSeconds -= currentPauseDuration;
      }
      
      // Clamp to minimum 0, maximum total duration
      return Duration(seconds: activeDurationSeconds.clamp(0, totalDuration.inSeconds));
    } catch (e) {
      // Fallback: return zero duration on any error
      return Duration.zero;
    }
  }

  /// Total elapsed time including pauses
  /// Protected: never throws
  Duration get totalElapsed {
    try {
      final end = endTime ?? DateTime.now();
      final elapsed = end.difference(startTime);
      return elapsed.isNegative ? Duration.zero : elapsed;
    } catch (e) {
      return Duration.zero;
    }
  }

  /// Format duration as HH:MM:SS
  String get formattedDuration {
    final d = duration;
    final hours = d.inHours.toString().padLeft(2, '0');
    final minutes = (d.inMinutes % 60).toString().padLeft(2, '0');
    final seconds = (d.inSeconds % 60).toString().padLeft(2, '0');
    return '$hours:$minutes:$seconds';
  }

  Activity copyWith({
    String? id,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? deviceId,
    String? userId,
    SyncStatus? syncStatus,
    String? name,
    String? category,
    DateTime? startTime,
    DateTime? endTime,
    bool? isAutoGenerated,
    bool? isRunning,
    bool? isPaused,
    int? pausedDurationSeconds,
    DateTime? pausedAt,
    ActivitySource? source,
    String? guidedFlowId,
    String? chainContext,
  }) {
    return Activity(
      id: id ?? this.id,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? DateTime.now().toUtc(), // Always update timestamp on modification (UTC)
      deviceId: deviceId ?? this.deviceId,
      userId: userId ?? this.userId,
      syncStatus: syncStatus ?? SyncStatus.pending, // Reset to pending on any change unless explicitly set
      name: name ?? this.name,
      category: category ?? this.category,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
      isRunning: isRunning ?? this.isRunning,
      isPaused: isPaused ?? this.isPaused,
      pausedDurationSeconds: pausedDurationSeconds ?? this.pausedDurationSeconds,
      pausedAt: pausedAt ?? this.pausedAt,
      source: source ?? this.source,
      guidedFlowId: guidedFlowId ?? this.guidedFlowId,
      chainContext: chainContext ?? this.chainContext,
    );
  }

  @override
  Activity copyWithStatus(SyncStatus status) {
    return copyWith(syncStatus: status, updatedAt: updatedAt); // Don't verify updatedAt for sync status updates
  }

  @override
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
      'user_id': userId,
      'device_id': deviceId,
      'sync_status': syncStatus.index, // Store as integer in SQLite
      'name': name,
      'category': category,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime?.toIso8601String(),
      'is_auto_generated': isAutoGenerated ? 1 : 0,
      'is_running': isRunning ? 1 : 0,
      'is_paused': isPaused ? 1 : 0,
      'paused_duration_seconds': pausedDurationSeconds,
      'paused_at': pausedAt?.toIso8601String(),
      'source': source.name,
      'guided_flow_id': guidedFlowId,
      'chain_context': chainContext,
    };
  }

  /// Map for Supabase (uses snake_case and excludes local-only fields)
  /// USER-SCOPED: Includes user_id as primary owner
  @override
  Map<String, dynamic> toSupabaseMap() {
    return {
      'id': id,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
      'user_id': userId,
      'device_id': deviceId,
      'name': name,
      'category': category,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime?.toIso8601String(),
      'is_running': isRunning ? 1 : 0,
      'is_paused': isPaused ? 1 : 0,
      'paused_duration_seconds': pausedDurationSeconds,
      'paused_at': pausedAt?.toIso8601String(),
      'source': source.name,
      'guided_flow_id': guidedFlowId,
    };
  }

  factory Activity.fromMap(Map<String, dynamic> map) {
    return Activity(
      id: map['id'] as String,
      createdAt: DateTime.parse(map['created_at'] as String),
      updatedAt: DateTime.parse(map['updated_at'] as String),
      userId: map['user_id'] as String?,
      deviceId: map['device_id'] as String?,
      syncStatus: SyncStatus.values[map['sync_status'] as int? ?? 1], // Default to pending if missing
      name: map['name'] as String,
      category: map['category'] as String? ?? 'Uncategorized',
      startTime: DateTime.parse(map['start_time'] as String),
      endTime: map['end_time'] != null ? DateTime.parse(map['end_time'] as String) : null,
      isAutoGenerated: (map['is_auto_generated'] as int?) == 1,
      isRunning: (map['is_running'] as int?) == 1,
      isPaused: (map['is_paused'] as int?) == 1,
      pausedDurationSeconds: map['paused_duration_seconds'] as int? ?? 0,
      pausedAt: map['paused_at'] != null ? DateTime.parse(map['paused_at'] as String) : null,
      source: ActivitySource.fromString(map['source'] as String? ?? 'manual'),
      guidedFlowId: map['guided_flow_id'] as String?,
      chainContext: map['chain_context'] as String?,
    );
  }

  /// Factory for parsing Supabase response (handles booleans vs ints)
  /// USER-SCOPED: Reads user_id and all running state fields
  factory Activity.fromSupabaseMap(Map<String, dynamic> map) {
    // Supabase returns actual booleans, not integers
    bool parseBool(dynamic value) {
      if (value == null) return false;
      if (value is bool) return value;
      if (value is int) return value == 1;
      return false;
    }
    
    return Activity(
      id: map['id'] as String,
      createdAt: DateTime.parse(map['created_at'] as String),
      updatedAt: DateTime.parse(map['updated_at'] as String),
      userId: map['user_id'] as String?,
      deviceId: map['device_id'] as String?,
      syncStatus: SyncStatus.synced,
      name: map['name'] as String,
      category: map['category'] as String? ?? 'Uncategorized',
      startTime: DateTime.parse(map['start_time'] as String),
      endTime: map['end_time'] != null ? DateTime.parse(map['end_time'] as String) : null,
      isAutoGenerated: parseBool(map['is_auto_generated']),
      isRunning: parseBool(map['is_running']),
      isPaused: parseBool(map['is_paused']),
      pausedDurationSeconds: map['paused_duration_seconds'] as int? ?? 0,
      pausedAt: map['paused_at'] != null ? DateTime.parse(map['paused_at'] as String) : null,
      source: ActivitySource.fromString(map['source'] as String? ?? 'manual'),
      guidedFlowId: map['guided_flow_id'] as String?,
    );
  }

  @override
  String toString() {
    return 'Activity(id: $id, name: $name, status: $syncStatus)';
  }
}
